package tests

import (
	"github.com/ianamason/yices2_go_bindings/yices2"
	"testing"
)

func TestTerms0(t *testing.T) {
	yices2.Init()


	true_ := yices2.True()
	false_ := yices2.False()
	bool_t := yices2.Bool_type()
	int_t := yices2.Int_type()
	unint_t := yices2.New_uninterpreted_type()
	AssertNotEqual(t, true_, false_)
	const1 := yices2.Constant(unint_t, 0)
	AssertNotEqual(t, const1, yices2.NULL_TERM)
	const2 := yices2.New_uninterpreted_term(unint_t)
	AssertNotEqual(t, const2, yices2.NULL_TERM)
	bconst1 := yices2.New_uninterpreted_term(bool_t)
	iconst1 := yices2.New_uninterpreted_term(int_t)
	var1 := yices2.New_variable(unint_t)
	bvar1 := yices2.New_variable(bool_t)
	AssertNotEqual(t, bvar1, yices2.NULL_TERM)
	ivar1 := yices2.New_variable(int_t)
	ivar2 := yices2.New_variable(int_t)
	ivar3 := yices2.New_variable(int_t)
	ivar4 := yices2.New_variable(int_t)
	zero := yices2.Zero()
	int1 := yices2.Int32(13)
	int2 := yices2.Int32(17)
	AssertEqual(t, zero, yices2.Int32(0))
	fun1_t := yices2.Function_type1(int_t, bool_t)
	fun1 := yices2.New_variable(fun1_t)
	app1 := yices2.Application1(fun1, int1)
	AssertNotEqual(t, app1, yices2.NULL_TERM)
	fun2_t := yices2.Function_type2(int_t, int_t, bool_t)
	fun2 := yices2.New_variable(fun2_t)
	app2 := yices2.Application2(fun2, int1, int1)
	AssertNotEqual(t, app2, yices2.NULL_TERM)
	fun3_t := yices2.Function_type3(int_t, int_t, int_t, bool_t)
	fun3 := yices2.New_variable(fun3_t)
	app3 := yices2.Application3(fun3, int1, int1, int1)
	AssertNotEqual(t, app3, yices2.NULL_TERM)
	tup3_t := yices2.Tuple_type3(bool_t, int_t, unint_t)
	tupconst1 := yices2.New_variable(tup3_t)
	ta4 := []yices2.Type_t{int_t, int_t, int_t, int_t}
	int4 := []yices2.Term_t{int1, int2, iconst1, ivar1}
	int4_2 := []yices2.Term_t{ivar1, ivar2, ivar3, ivar4}
	fun4_t := yices2.Function_type(ta4, bool_t)
	fun4 := yices2.New_variable(fun4_t)
	app4 := yices2.Application(fun4, int4)
	ite1 := yices2.Ite(bconst1, int1, int2)
	eq1 := yices2.Eq(int1, int1)
	neq1 := yices2.Neq(int1, int1)
	not1 := yices2.Not(false_)
	AssertNotEqual(t, not1, yices2.NULL_TERM)
	bool5 := []yices2.Term_t{false_, eq1, neq1, app4, false_}
	or1 := yices2.Or(bool5)
	AssertNotEqual(t, or1, yices2.NULL_TERM)
	and1 := yices2.And(bool5)
	AssertNotEqual(t, and1, yices2.NULL_TERM)
	xor1 := yices2.Xor(bool5)
	AssertNotEqual(t, xor1, yices2.NULL_TERM)
	or2 := yices2.Or2(or1, and1)
	and2 := yices2.And2(or1, and1)
	xor2 := yices2.Xor2(or1, and1)
	or3 := yices2.Or3(or1, and1, or2)
	and3 := yices2.And3(or1, and1, and2)
	AssertNotEqual(t, and3, yices2.NULL_TERM)
	xor3 := yices2.Xor3(or1, and1, xor2)
	AssertNotEqual(t, xor3, yices2.NULL_TERM)
	iff1 := yices2.Iff(and1, or1)
	AssertNotEqual(t, iff1, yices2.NULL_TERM)
	implies1 := yices2.Implies(and1, or1)
	AssertNotEqual(t, implies1, yices2.NULL_TERM)
	tup1 := yices2.Tuple(int4)
	AssertNotEqual(t, tup1, yices2.NULL_TERM)
	pair1 := yices2.Pair(eq1, xor2)
	AssertNotEqual(t, pair1, yices2.NULL_TERM)
	triple1 := yices2.Triple(ite1, fun4, or3)
	AssertNotEqual(t, triple1, yices2.NULL_TERM)
	select1 := yices2.Select(2, tup1)
	AssertNotEqual(t, select1, yices2.NULL_TERM)
	select2 := yices2.Select(2, tupconst1)
	AssertNotEqual(t, select2, yices2.NULL_TERM)
	tupup1 := yices2.Tuple_update(tup1, 2, int2)
	AssertNotEqual(t, tupup1, yices2.NULL_TERM)
	update1 := yices2.Update1(fun1, int1, false_)
	AssertNotEqual(t, update1, yices2.NULL_TERM)
	update2 := yices2.Update2(fun2, int1, int1, false_)
	AssertNotEqual(t, update2, yices2.NULL_TERM)
	update3 := yices2.Update3(fun3, int1, int1, int1, false_)
	AssertNotEqual(t, update3, yices2.NULL_TERM)
	update4 := yices2.Update(fun4, int4, false_)
	AssertNotEqual(t, update4, yices2.NULL_TERM)
	distinct1 := yices2.Distinct(int4)
	AssertNotEqual(t, distinct1, yices2.NULL_TERM)
	var2 := yices2.New_variable(unint_t)
	AssertNotEqual(t, var2, yices2.NULL_TERM)
	vareq := yices2.Eq(var1, var2)
	AssertNotEqual(t, vareq, yices2.NULL_TERM)
	vars2 := []yices2.Term_t{var1, var2}
	AssertNotEqual(t, vars2, yices2.NULL_TERM)
	forall1 := yices2.Forall(vars2, vareq)
	AssertNotEqual(t, forall1, yices2.NULL_TERM)
	exists1 := yices2.Exists(vars2, vareq)
	AssertNotEqual(t, exists1, yices2.NULL_TERM)
	lambda1 := yices2.Lambda(vars2, vareq)
	AssertNotEqual(t, lambda1, yices2.NULL_TERM)
	int64_1 := yices2.Int64(42)
	AssertNotEqual(t, int64_1, yices2.NULL_TERM)
	rat32_1 := yices2.Rational32(13, 7)
	AssertNotEqual(t, rat32_1, yices2.NULL_TERM)
	rat64_1 := yices2.Rational64(-47, 111)
	AssertNotEqual(t, rat64_1, yices2.NULL_TERM)
	rat1 := yices2.Parse_rational("-3/117")
	AssertNotEqual(t, rat1, yices2.NULL_TERM)
	float1 := yices2.Parse_float("-3.117e-2")
	AssertNotEqual(t, float1, yices2.NULL_TERM)
	add1 := yices2.Add(int1, int1)
	AssertNotEqual(t, add1, yices2.NULL_TERM)
	sub1 := yices2.Sub(int1, zero)
	AssertNotEqual(t, sub1, yices2.NULL_TERM)
	neg1 := yices2.Neg(int1)
	AssertNotEqual(t, neg1, yices2.NULL_TERM)
	AssertEqual(t, yices2.Neg(zero), zero)
	AssertNotEqual(t, neg1, int1)
	mul1 := yices2.Mul(int1, int1)
	AssertNotEqual(t, mul1, yices2.NULL_TERM)
	square1 := yices2.Square(int1)
	AssertEqual(t, mul1, square1)
	power1 := yices2.Power(int1, 4)
	AssertNotEqual(t, power1, yices2.NULL_TERM)
	sum1 := yices2.Sum(int4)
	AssertNotEqual(t, sum1, yices2.NULL_TERM)
	product1 := yices2.Product(int4)
	AssertNotEqual(t, product1, yices2.NULL_TERM)
	product2 := yices2.Product(int4_2)
	AssertNotEqual(t, product2, yices2.NULL_TERM)
	div1 := yices2.Division(int1, int1)
	AssertNotEqual(t, div1, yices2.NULL_TERM)
	idiv1 := yices2.Idiv(int1, int1)
	AssertNotEqual(t, idiv1, yices2.NULL_TERM)
	imod1 := yices2.Imod(int1, int1)
	AssertNotEqual(t, imod1, yices2.NULL_TERM)
	divatom1 := yices2.Divides_atom(int1, int1)
	AssertNotEqual(t, divatom1, yices2.NULL_TERM)
	intatom1 := yices2.Is_int_atom(int1)
	AssertNotEqual(t, intatom1, yices2.NULL_TERM)
	abs1 := yices2.Abs(neg1)
	AssertEqual(t, abs1, int1)
	floor1 := yices2.Floor(rat1)
	AssertNotEqual(t, floor1, yices2.NULL_TERM)
	ceil1 := yices2.Ceil(rat1)
	AssertNotEqual(t, ceil1, yices2.NULL_TERM)
	poly32 := yices2.Poly_int32([]int32{2, 3, 4, 5}, int4)
	AssertNotEqual(t, poly32, yices2.NULL_TERM)
	poly64 := yices2.Poly_int64([]int64{3, 4, 5, 6}, int4)
	AssertNotEqual(t, poly64, yices2.NULL_TERM)
	polyrat32 := yices2.Poly_rational32([]int32{2, 3, 4, 5}, []uint32{12, 13, 14, 15}, int4)
	AssertNotEqual(t, polyrat32, yices2.NULL_TERM)
	polyrat64 := yices2.Poly_rational64([]int64{2, 3, 4, 5}, []uint64{12, 13, 14, 15}, int4)
	AssertNotEqual(t, polyrat64, yices2.NULL_TERM)
	areqatom1 := yices2.Arith_eq_atom(int1, zero)
	AssertNotEqual(t, areqatom1, yices2.NULL_TERM)
	arneqatom1 := yices2.Arith_neq_atom(int1, zero)
	AssertNotEqual(t, arneqatom1, yices2.NULL_TERM)
	argeqatom1 := yices2.Arith_geq_atom(int1, zero)
	AssertNotEqual(t, argeqatom1, yices2.NULL_TERM)
	arleqatom1 := yices2.Arith_leq_atom(int1, zero)
	AssertNotEqual(t, arleqatom1, yices2.NULL_TERM)
	argtatom1 := yices2.Arith_gt_atom(int1, zero)
	AssertNotEqual(t, argtatom1, yices2.NULL_TERM)
	arltatom1 := yices2.Arith_lt_atom(int1, zero)
	AssertNotEqual(t, arltatom1, yices2.NULL_TERM)
	areq0atom1 := yices2.Arith_eq0_atom(int1)
	AssertNotEqual(t, areq0atom1, yices2.NULL_TERM)
	arneq0atom1 := yices2.Arith_neq0_atom(int1)
	AssertNotEqual(t, arneq0atom1, yices2.NULL_TERM)
	argeq0atom1 := yices2.Arith_geq0_atom(int1)
	AssertNotEqual(t, argeq0atom1, yices2.NULL_TERM)
	arleq0atom1 := yices2.Arith_leq0_atom(int1)
	AssertNotEqual(t, arleq0atom1, yices2.NULL_TERM)
	argt0atom1 := yices2.Arith_gt0_atom(int1)
	AssertNotEqual(t, argt0atom1, yices2.NULL_TERM)
	arlt0atom1 := yices2.Arith_lt0_atom(int1)
	AssertNotEqual(t, arlt0atom1, yices2.NULL_TERM)
	bv_t := yices2.Bv_type(8)
	AssertNotEqual(t, bv_t, yices2.NULL_TYPE)
	bvconstu32_1 := yices2.Bvconst_uint32(8, 42)
	AssertNotEqual(t, bvconstu32_1, yices2.NULL_TYPE)
	bvconstu64_1 := yices2.Bvconst_uint64(8, 42)
	AssertNotEqual(t, bvconstu64_1, yices2.NULL_TYPE)
	bvconst32_1 := yices2.Bvconst_int32(8, 42)
	AssertNotEqual(t, bvconst32_1, yices2.NULL_TYPE)
	bvconst64_1 := yices2.Bvconst_int64(8, 42)
	AssertNotEqual(t, bvconst64_1, yices2.NULL_TYPE)
	bvconstzero_1 := yices2.Bvconst_zero(16)
	AssertNotEqual(t, bvconstzero_1, yices2.NULL_TYPE)
	bvconstone_1 := yices2.Bvconst_one(16)
	AssertNotEqual(t, bvconstone_1, yices2.NULL_TERM)
	bvconstminusone_1 := yices2.Bvconst_minus_one(32)
	AssertNotEqual(t, bvconstminusone_1, yices2.NULL_TERM)
	bvconstarray1 := yices2.Bvconst_from_array([]int32{1, 0, 1, 0})
	AssertNotEqual(t, bvconstarray1, yices2.NULL_TERM)
	bvvar1 := yices2.New_variable(bv_t)
	AssertNotEqual(t, bvvar1, yices2.NULL_TERM)
	bvvar2 := yices2.New_variable(bv_t)
	AssertNotEqual(t, bvvar2, yices2.NULL_TERM)
	bvvar3 := yices2.New_variable(bv_t)
	AssertNotEqual(t, bvvar3, yices2.NULL_TERM)
	bvvar4 := yices2.New_variable(bv_t)
	AssertNotEqual(t, bvvar4, yices2.NULL_TERM)
	bvbin1 := yices2.Parse_bvbin("100101")
	AssertNotEqual(t, bvbin1, yices2.NULL_TERM)
	bvhex1 := yices2.Parse_bvhex("f0a1b3")
	AssertNotEqual(t, bvhex1, yices2.NULL_TERM)
	bvadd1 := yices2.Bvadd(bvbin1, bvbin1)
	AssertNotEqual(t, bvadd1, yices2.NULL_TERM)
	bvsub1 := yices2.Bvsub(bvbin1, bvbin1)
	AssertNotEqual(t, bvsub1, yices2.NULL_TERM)
	bvneg1 := yices2.Bvneg(bvbin1)
	AssertNotEqual(t, bvneg1, yices2.NULL_TERM)
	bvmul1 := yices2.Bvmul(bvbin1, bvbin1)
	AssertNotEqual(t, bvmul1, yices2.NULL_TERM)
	bvsquare1 := yices2.Bvsquare(bvbin1)
	AssertNotEqual(t, bvsquare1, yices2.NULL_TERM)
	bvpower1 := yices2.Bvpower(bvbin1, 3)
	AssertNotEqual(t, bvpower1, yices2.NULL_TERM)
	bvdiv1 := yices2.Bvdiv(bvbin1, bvbin1)
	AssertNotEqual(t, bvdiv1, yices2.NULL_TERM)
	bvrem1 := yices2.Bvrem(bvbin1, bvbin1)
	AssertNotEqual(t, bvrem1, yices2.NULL_TERM)
	bvsdiv1 := yices2.Bvsdiv(bvbin1, bvbin1)
	AssertNotEqual(t, bvsdiv1, yices2.NULL_TERM)
	bvsrem1 := yices2.Bvsrem(bvbin1, bvbin1)
	AssertNotEqual(t, bvsrem1, yices2.NULL_TERM)
	bvsmod1 := yices2.Bvsmod(bvbin1, bvbin1)
	AssertNotEqual(t, bvsmod1, yices2.NULL_TERM)
	bvnot1 := yices2.Bvnot(bvbin1)
	AssertNotEqual(t, bvnot1, yices2.NULL_TERM)
	bvnand1 := yices2.Bvnand(bvbin1, bvbin1)
	AssertNotEqual(t, bvnand1, yices2.NULL_TERM)
	bvnor1 := yices2.Bvnor(bvbin1, bvbin1)
	AssertNotEqual(t, bvnor1, yices2.NULL_TERM)
	bvxnor1 := yices2.Bvxnor(bvbin1, bvbin1)
	AssertNotEqual(t, bvxnor1, yices2.NULL_TERM)
	bvshl1 := yices2.Bvshl(bvbin1, bvbin1)
	AssertNotEqual(t, bvshl1, yices2.NULL_TERM)
	bvlshr1 := yices2.Bvlshr(bvbin1, bvbin1)
	AssertNotEqual(t, bvlshr1, yices2.NULL_TERM)
	bvashr1 := yices2.Bvashr(bvbin1, bvbin1)
	AssertNotEqual(t, bvashr1, yices2.NULL_TERM)
	bvand1 := yices2.Bvand([]yices2.Term_t{bvbin1, bvbin1, bvbin1, bvbin1})
	AssertNotEqual(t, bvand1, yices2.NULL_TERM)
	bvor1 := yices2.Bvor([]yices2.Term_t{bvbin1, bvbin1, bvbin1, bvbin1})
	AssertNotEqual(t, bvor1, yices2.NULL_TERM)
	bvand2_1 := yices2.Bvand2(bvbin1, bvbin1)
	AssertNotEqual(t, bvand2_1, yices2.NULL_TERM)
	bvor2_1 := yices2.Bvor2(bvbin1, bvbin1)
	AssertNotEqual(t, bvor2_1, yices2.NULL_TERM)
	bvxor2_1 := yices2.Bvxor2(bvbin1, bvbin1)
	AssertNotEqual(t, bvxor2_1, yices2.NULL_TERM)
	bvand3_1 := yices2.Bvand3(bvbin1, bvbin1, bvbin1)
	AssertNotEqual(t, bvand3_1, yices2.NULL_TERM)
	bvor3_1 := yices2.Bvor3(bvbin1, bvbin1, bvbin1)
	AssertNotEqual(t, bvor3_1, yices2.NULL_TERM)
	bvxor3_1 := yices2.Bvxor3(bvbin1, bvbin1, bvbin1)
	AssertNotEqual(t, bvxor3_1, yices2.NULL_TERM)
	bvsum1 := yices2.Bvsum([]yices2.Term_t{bvbin1, bvbin1, bvbin1, bvbin1})
	AssertNotEqual(t, bvsum1, yices2.NULL_TERM)
	bvsum2 := yices2.Bvsum([]yices2.Term_t{bvvar1, bvvar2, bvvar3, bvvar4})
	AssertNotEqual(t, bvsum2, yices2.NULL_TERM)
	bvproduct1 := yices2.Bvproduct([]yices2.Term_t{bvbin1, bvbin1, bvbin1, bvbin1})
	AssertNotEqual(t, bvproduct1, yices2.NULL_TERM)
	shleft0_1 := yices2.Shift_left0(bvbin1, 5)
	AssertNotEqual(t, shleft0_1, yices2.NULL_TERM)
	shleft1_1 := yices2.Shift_left1(bvbin1, 4)
	AssertNotEqual(t, shleft1_1, yices2.NULL_TERM)
	shright0_1 := yices2.Shift_right0(bvbin1, 3)
	AssertNotEqual(t, shright0_1, yices2.NULL_TERM)
	shright1_1 := yices2.Shift_right1(bvbin1, 2)
	AssertNotEqual(t, shright1_1, yices2.NULL_TERM)
	ashright_1 := yices2.Ashift_right(bvbin1, 1)
	AssertNotEqual(t, ashright_1, yices2.NULL_TERM)
	rotleft_1 := yices2.Rotate_left(bvbin1, 6)
	AssertNotEqual(t, rotleft_1, yices2.NULL_TERM)
	rotright_1 := yices2.Rotate_right(bvbin1, 5)
	AssertNotEqual(t, rotright_1, yices2.NULL_TERM)
	bvextract1 := yices2.Bvextract(bvbin1, 2, 4)
	AssertNotEqual(t, bvextract1, yices2.NULL_TERM)
	bvconcat2_1 := yices2.Bvconcat2(bvbin1, bvbin1)
	AssertNotEqual(t, bvconcat2_1, yices2.NULL_TERM)
	bvconcat_1 := yices2.Bvconcat([]yices2.Term_t{bvbin1, bvbin1, bvbin1, bvbin1})
	AssertNotEqual(t, bvconcat_1, yices2.NULL_TERM)
	bvrepeat1 := yices2.Bvrepeat(bvbin1, 8)
	AssertNotEqual(t, bvrepeat1, yices2.NULL_TERM)
	signext1 := yices2.Sign_extend(bvbin1, 3)
	AssertNotEqual(t, signext1, yices2.NULL_TERM)
	zeroext1 := yices2.Zero_extend(bvbin1, 4)
	AssertNotEqual(t, zeroext1, yices2.NULL_TERM)
	redand1 := yices2.Redand(bvbin1)
	AssertNotEqual(t, redand1, yices2.NULL_TERM)
	redor1 := yices2.Redor(bvbin1)
	AssertNotEqual(t, redor1, yices2.NULL_TERM)
	redcomp1 := yices2.Redcomp(bvbin1, bvbin1)
	AssertNotEqual(t, redcomp1, yices2.NULL_TERM)
	bvarray1 := yices2.Bvarray([]yices2.Term_t{true_, false_, true_, false_})
	AssertNotEqual(t, bvarray1, yices2.NULL_TERM)
	bitextract1 := yices2.Bitextract(bvbin1, 3)
	AssertNotEqual(t,bitextract1 , yices2.NULL_TERM)
	bveqatom1 := yices2.Bveq_atom(bvbin1, bvbin1)
	AssertNotEqual(t, bveqatom1, yices2.NULL_TERM)
	bvneqatom1 := yices2.Bvneq_atom(bvbin1, bvbin1)
	AssertNotEqual(t, bvneqatom1, yices2.NULL_TERM)
	bvgeatom1 := yices2.Bvge_atom(bvbin1, bvbin1)
	AssertNotEqual(t, bvgeatom1, yices2.NULL_TERM)
	bvgtatom1 := yices2.Bvgt_atom(bvbin1, bvbin1)
	AssertNotEqual(t, bvgtatom1, yices2.NULL_TERM)
	bvleatom1 := yices2.Bvle_atom(bvbin1, bvbin1)
	AssertNotEqual(t, bvleatom1, yices2.NULL_TERM)
	bvltatom1 := yices2.Bvlt_atom(bvbin1, bvbin1)
	AssertNotEqual(t, bvltatom1, yices2.NULL_TERM)
	bvsgeatom1 := yices2.Bvsge_atom(bvbin1, bvbin1)
	AssertNotEqual(t, bvsgeatom1, yices2.NULL_TERM)
	bvsgtatom1 := yices2.Bvsgt_atom(bvbin1, bvbin1)
	AssertNotEqual(t, bvsgtatom1, yices2.NULL_TERM)
	bvsleatom1 := yices2.Bvsle_atom(bvbin1, bvbin1)
	AssertNotEqual(t, bvsleatom1, yices2.NULL_TERM)
	bvsltatom1 := yices2.Bvslt_atom(bvbin1, bvbin1)
	AssertNotEqual(t, bvsltatom1, yices2.NULL_TERM)
	ptype1 := yices2.Parse_type("int")
	AssertEqual(t, ptype1, yices2.Int_type())
	pterm1 := yices2.Parse_term("42")
	AssertEqual(t, pterm1, yices2.Int32(42))
	subst1 := yices2.Subst_term([]yices2.Term_t{yices2.New_variable(ptype1),yices2.New_variable(ptype1)},
		[]yices2.Term_t{yices2.Int32(2), yices2.Int32(3)},
		yices2.Int32(42))
	AssertNotEqual(t, subst1, yices2.NULL_TERM)
	substarr1 := yices2.Subst_term_array([]yices2.Term_t{yices2.New_variable(ptype1), yices2.New_variable(ptype1)},
		[]yices2.Term_t{yices2.Int32(2), yices2.Int32(3)},
		[]yices2.Term_t{yices2.Int32(2), yices2.Int32(3), yices2.Int32(7)})
	AssertNotEqual(t, substarr1, yices2.NULL_TERM)
	settypename1 := yices2.Set_type_name(ptype1, "I")
	AssertEqual(t, settypename1, int32(0))
	settermname1 := yices2.Set_term_name(pterm1, "answer")
	AssertEqual(t, settermname1, 0)
	gettype1 := yices2.Get_type_by_name("I")
	AssertEqual(t, gettype1, ptype1)
	getterm1 := yices2.Get_term_by_name("answer")
	AssertEqual(t, getterm1, pterm1)
	gettypename1 := yices2.Get_type_name(ptype1)
	AssertEqual(t, gettypename1, "I")
	gettermname1 := yices2.Get_term_name(pterm1)
	AssertEqual(t, gettermname1, "answer")
	yices2.Remove_type_name("I")
	yices2.Remove_term_name("answer")
	yices2.Clear_type_name(ptype1)
	yices2.Clear_term_name(pterm1)
	typeofterm1 := yices2.Type_of_term(pterm1)
	AssertEqual(t, typeofterm1, yices2.Int_type())
	AssertTrue(t, yices2.Term_is_bool(false_))
	AssertFalse(t, yices2.Term_is_bool(pterm1))
	AssertFalse(t, yices2.Term_is_int(false_))
	AssertTrue(t, yices2.Term_is_int(pterm1))
	AssertFalse(t, yices2.Term_is_real(false_))
	AssertFalse(t, yices2.Term_is_real(pterm1))
	AssertFalse(t, yices2.Term_is_arithmetic(false_))
	AssertTrue(t, yices2.Term_is_arithmetic(pterm1))
	AssertFalse(t, yices2.Term_is_bitvector(false_))
	AssertTrue(t, yices2.Term_is_bitvector(bvbin1))
	AssertFalse(t, yices2.Term_is_tuple(false_))
	AssertTrue(t, yices2.Term_is_tuple(tup1))
	AssertFalse(t, yices2.Term_is_function(false_))
	AssertTrue(t, yices2.Term_is_function(fun1))
	AssertFalse(t, yices2.Term_is_scalar(false_))
	AssertFalse(t, yices2.Term_is_scalar(fun1))
	AssertEqual(t, yices2.Term_bitsize(bvbin1), uint32(6))  //yuk
	AssertTrue(t, yices2.Term_is_ground(false_))
	AssertFalse(t, yices2.Term_is_ground(var1))
	AssertTrue(t, yices2.Term_is_atomic(false_))
	// or1 is atomic because it simplifies to true
	AssertTrue(t, yices2.Term_is_atomic(or1))
	AssertFalse(t, yices2.Term_is_composite(false_))
	AssertTrue(t, yices2.Term_is_composite(ite1))
	AssertTrue(t, yices2.Term_is_composite(tup1))
	AssertFalse(t, yices2.Term_is_projection(false_))
	// Select1 simplifies
	AssertFalse(t, yices2.Term_is_projection(select1))
	AssertTrue(t, yices2.Term_is_projection(select2))
	AssertFalse(t, yices2.Term_is_sum(ite1))
	AssertTrue(t, yices2.Term_is_sum(sum1))
	AssertFalse(t, yices2.Term_is_bvsum(select1))
	// bvsum1 simplifies since the terms are all numbers
	AssertFalse(t, yices2.Term_is_bvsum(bvsum1))
	AssertTrue(t, yices2.Term_is_bvsum(bvsum2))
	AssertFalse(t, yices2.Term_is_product(ite1))
	AssertFalse(t, yices2.Term_is_product(product1))
	AssertTrue(t, yices2.Term_is_product(product2))
	AssertEqual(t, yices2.Term_constructor(true_), yices2.Term_constructor_t(0)) //yuk
	AssertEqual(t, yices2.Term_constructor(int1), yices2.Term_constructor_t(1)) //yuk
	AssertEqual(t, yices2.Term_constructor(bvconst32_1), yices2.Term_constructor_t(2)) //yuk
	AssertEqual(t, yices2.Term_num_children(bvconst32_1), 0)
	AssertEqual(t, yices2.Term_num_children(select2), 1)

	AssertEqual(t, yices2.Term_num_children(tup1), 4)
	AssertEqual(t, yices2.Term_child(tup1, 2), iconst1)
	projarg1 := yices2.Proj_arg(select2)
	AssertNotEqual(t, projarg1, yices2.NULL_TERM)
	AssertEqual(t, yices2.Proj_index(select2), 2)
	AssertEqual(t, yices2.Proj_arg(select2), tupconst1)
	var val int32
	AssertEqual(t, yices2.Bool_const_value(true_, &val), 0)
	AssertEqual(t, val, 1)
	bval := []int32{0, 0, 0, 0, 0, 0, 0, 0}
	AssertEqual(t, yices2.Bv_const_value(bvconst32_1, bval), 0)
	AssertEqual(t, bval[0:7], []int32{0, 1, 0, 1, 0, 1, 0})
	scalar_t := yices2.New_scalar_type(20)
	scalar_c := yices2.Constant(scalar_t, 13)
	AssertEqual(t, yices2.Scalar_const_value(scalar_c, &val), 0)
	AssertEqual(t, val, 13)
	AssertEqual(t, yices2.Type_of_term(bvsum2), yices2.Type_t(13))  //BD: not very robust
	// val must be an array of eight integers since bvsum has type (bitvector 8)
	var term yices2.Term_t
	dodgy := yices2.Bvsum_component(bvsum2, 1, bval, &term)
	AssertEqual(t, dodgy, 0)
	AssertTrue(t, yices2.Term_is_bitvector(term))
	AssertTrue(t, yices2.Term_is_bitvector(bvvar2))
	AssertEqual(t, bval[0], 1)
	AssertEqual(t, bval[1], 0)
	AssertEqual(t, bval[2], 0)
	AssertEqual(t, bval[3], 0)
	AssertEqual(t, bval[4], 0)
	AssertEqual(t, bval[5], 0)
	AssertEqual(t, bval[6], 0)
	AssertEqual(t, bval[7], 0)
	AssertEqual(t, term, bvvar2)
	var exp1 uint32
	AssertEqual(t, yices2.Product_component(product2, 1, &term, &exp1), 0)
	AssertEqual(t, exp1, uint32(1))
	AssertEqual(t, term, ivar2)
	// Note that the next two can change easily
	AssertEqual(t, yices2.Num_terms(), uint32(102))
	AssertEqual(t, yices2.Num_types(), uint32(26))
	AssertEqual(t, yices2.Incref_term(term), 0)
	AssertEqual(t, yices2.Num_posref_terms(), uint32(1))
	AssertEqual(t, yices2.Decref_term(term), 0)
	AssertEqual(t, yices2.Num_posref_terms(), uint32(0))
	AssertEqual(t, yices2.Incref_type(unint_t), 0)
	AssertEqual(t, yices2.Num_posref_types(), uint32(1))
	AssertEqual(t, yices2.Decref_type(unint_t), 0)
	AssertEqual(t, yices2.Num_posref_types(), uint32(0))
	AssertEqual(t, yices2.Incref_term(int1), 0)
	AssertEqual(t, yices2.Incref_type(int_t), 0)
	yices2.Garbage_collect(int4, ta4, 0)
	AssertEqual(t, yices2.Num_terms(), uint32(7))
	AssertEqual(t, yices2.Num_types(), uint32(3))

	yices2.Exit()

}
